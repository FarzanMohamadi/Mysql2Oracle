<?php
namespace DatabaseConverter;

use PDO;
use PDOStatement;
use Exception;

class MySQLToOracleConverter
{
    /**
     * Converts MySQL SQL query to Oracle-compatible SQL.
     *
     * @param string &$sql The MySQL SQL query to be converted.
     */
    public static function convertSqlForOracle(string &$sql): void
    {
        if (preg_match('/SELECT COL.COLUMN_NAME/i', $sql)) {
            return;
        }

        // Replace MySQL-specific keywords with equivalent Oracle keywords
        $keywords = array(
            '/\bAUTO_INCREMENT\b/i' => 'GENERATED BY DEFAULT ON NULL AS IDENTITY',
        );
        $columnsGroupBY = '';
        $sql = preg_replace(array_keys($keywords), array_values($keywords), $sql);

        // Replace MySQL-specific functions with equivalent Oracle functions
        $functions = array(
            '/\bDATE_FORMAT\b/i' => 'TO_CHAR',
            '/\bIFNULL\b/i' => 'NVL',
            '/\bNOW\(\)\b/i' => 'SYSDATE',
        );

        // Replace IF with CASE using regex
        $sql = preg_replace(array_keys($functions), array.values($functions), $sql);
        $sql = preg_replace('/IF\s*\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\s*\)/', 'CASE WHEN $1 THEN $2 ELSE $3 END', $sql);

        // Replace backticks with double quotations for table names and column names
        $sql = preg_replace('/`([^`]+)`/', '"$1"', $sql);
        $sql = preg_replace('/\s{2,}/', ' ', $sql);
        $sql = preg_replace('/show tables like :(\w+)/i', "SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE :$1", $sql);
        $sql = preg_replace("/SHOW VARIABLES LIKE '([^']+)%'/i", "SELECT name, value FROM v\$parameter WHERE name LIKE '$1%';", $sql);
        $sql = preg_replace('/SHOW VARIABLES LIKE ([\'"])([^\'"]+)\1/', 'SELECT name, value FROM v$parameter WHERE name LIKE '."'$2%'".' ', $sql);

        // Enclose column names and table names within double quotations
        $sql = preg_replace_callback('/\b(?:FROM|JOIN)\s+(\S+)/i', function($matches) {
            $tableName = $matches[1];
            if (strpos($tableName, '`') !== false || strpos($tableName, '"') !== false || strpos($tableName, '(') !== false || $tableName == 'v$parameter' || $tableName == 'ROWS') {
                return $matches[0];
            }
            return str_replace($tableName, '"' . $tableName . '"', $matches[0]);
        }, $sql);

        // Enclose table names within double quotations in UPDATE and INSERT statements
        $sql = preg_replace_callback('/\b(?:UPDATE|INSERT\s+INTO)\s+(\S+)/i', function($matches) {
            $tableName = $matches[1];
            if (strpos($tableName, '`') !== false || strpos($tableName, '"') !== false) {
                return $matches[0];
            }
            return str_replace($tableName, '"' . $tableName . '"', $matches[0]);
        }, $sql);

        $sql = preg_replace_callback('/(\b\w+\b)(?=\s*IN\b)/i', function($match) {
            if (trim(strtolower($match[1])) != 'not')
                return '"' . $match[1] . '"';
            else
                return $match[1];
        }, $sql);

        // Enclose column names in expressions like x.y within double quotations
        $sql = preg_replace_callback("/\.(\w+)'?/", function($dotMatch) {
            $last = substr($dotMatch[0], -1);
            if ($last == "'")
                return $dotMatch[0];
            else
                return '."' . $dotMatch[1] . '"';
        }, $sql);

        $sql = preg_replace_callback("/'?(\w+)\./", function($dotMatch) {
            $first = substr($dotMatch[0], 0, 1);
            if ($first == "'")
                return $dotMatch[0];
            else
                return '"' . $dotMatch[1] . '".';
        }, $sql);

        $sql = preg_replace('/"(\d+(?:\.\d+)?)"/', '$1', $sql);

        // Remove DISTINCT from count
        $sql = preg_replace('/count\s*\(\s*DISTINCT\s*(.*?)\s*\)/i', 'count($1)', $sql);
        $sql = preg_replace('/count\("(.*?)"\) "(.*?)"(?!\s*AS)/i', 'count("$1") AS "$2"', $sql);

        // LIMIT
        if (preg_match_all('/\bLIMIT\s+((:\w+)|(\d+)(?:\s*,\s*(\d+))?)(?:\s*,\s*((:\w+)|(\d+)(?:\s*,\s*(\d+))?))?\b/i', $sql, $limitMatches, PREG_SET_ORDER)) {
            foreach ($limitMatches as $match) {
                $limitClause = $match[0];
                $limitClause = str_replace(['LIMIT', ' ', '"'], '', $limitClause);
                $limitClause = explode(',', $limitClause);
                $offsets = array_map('trim', $limitClause);
                if (sizeof($offsets) == 1) {
                    $start = 0;
                    $end = $offsets[0];
                } else {
                    $start = $offsets[0];
                    $end = $offsets[1];
                }
                $replacement = 'OFFSET ' . $start . ' ROWS FETCH NEXT ' . $end . ' ROWS ONLY';
                $sql = preg_replace('/\bLIMIT\s+((:\w+)|(\d+)(?:\s*,\s*(\d+))?)(?:\s*,\s*((:\w+)|(\d+)(?:\s*,\s*(\d+))?))?\b/i', $replacement, $sql, 1);
            }
        }

        if (preg_match('/\bLIMIT\s+\?\s*,\s*\?/i', $sql)) {
            $sql = preg_replace('/\bLIMIT\s+\?\s*,\s*\?/i', 'OFFSET ? ROWS FETCH NEXT ? ROWS ONLY', $sql);
        }

        if (preg_match('/IF\s*\((.*?)\)/i', $sql)) {
            $sql = preg_replace('/IF\((.*?),\s*(.*?),\s*(.*?)\)/', 'CASE WHEN $1 THEN $2 ELSE $3 END', $sql);
        }

        if (strpos($sql, 'BASIC_ONLY') === false) {
            // Enclose column names after ORDER BY within double quotations
            if (preg_match('/\bORDER BY\b/i', $sql)) {
                $pattern = '/\bORDER\s+BY\s+([^;]+)/i';
                if (preg_match($pattern, $sql, $matches)) {
                    $orderByClause = $matches[1];
                    $containsComma = strpos($orderByClause, ',') !== false;
                }
                if ($containsComma) {
                    $sql = preg_replace('/ORDER BY (?!CASE\b|MAX\b)(?!.*\bcount\()(\\w+)/i', 'ORDER BY "$1"', $sql);
                    $sql = preg_replace('/ORDER BY(.*?)(?<=,|^)\s*([^,\s]{5,})/', 'ORDER BY$1 "$2"', $sql);
                } else {
                    $sql = preg_replace('/ORDER BY (?!CASE\b|MAX\b)(?!.*\bcount\()(\\w+)/i', 'ORDER BY "$1"', $sql);
                }

                // Remove max(argument) with argument
                $sql = preg_replace_callback('/ORDER\s+BY\s+(.*?)(MAX\([^)]+\))(.*)/i', function ($matches) {
                    $argument_inside_max = preg_replace('/MAX\(([^)]+)\)/i', '$1', $matches[2]);
                    return 'ORDER BY ' . $matches[1] . $argument_inside_max . $matches[3];
                }, $sql);
            }

            // AVG function
            $sql = preg_replace('/AVG\s*\([^()]*\)/i', '$0 OVER()', $sql);

            // GroupBy
            if (!preg_match('/^\s*DELETE\s+FROM\s+/i', $sql) && strpos($sql, 'NUMTODSINTERVAL') === false) {
                if (preg_match_all('/\bGROUP BY\b(?!\s+CASE)/i', $sql, $occourences)) {
                    if (count($occourences[0]) == 1) {
                        if (strpos($sql, 'FROM_UNIXTIME') === false ) {
                            $sql = preg_replace_callback('/GROUP\s+BY\s+(.*?)(?=(?:\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$))/i', function($matches) use (&$columnsGroupBY) {
                                $columnsGroupBY = $matches[1];
                            }, $sql);

                            if ($columnsGroupBY) {
                                $sql = preg_replace('/\bcount\s*\(\s*\*\s*\)/i', 'COUNT(' . $columnsGroupBY . ')', $sql);
                                preg_match('/count\(([^)]+)\)\s+AS\s+"([^"]+)"/i', $sql, $orderBycount);
                                $orderBycountMerge = '';
                                if ($orderBycount && $orderBycount[1]) {
                                    $orderBycountMerge = " ," . $orderBycount[1];
                                }

                                $sql = preg_replace('/SELECT\s+(.*?)\s+FROM\s+(.*?)(?=(?:\s+WHERE|\s+GROUP\s+BY|\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$))/i', 'SELECT $1, ROW_NUMBER() OVER (PARTITION BY ' . $columnsGroupBY . ' ORDER BY ' . $columnsGroupBY . $orderBycountMerge . ') "rn" FROM $2', $sql, 1);
                                $sql = 'SELECT * FROM (' . $sql . ') WHERE rn = 1';

                                // Transfer limit to the end of query
                                $lastLimit = "/OFFSET\s+(?:(\'\d+\')|(\d+)|(:\w+))\s+ROWS\s+FETCH\s+NEXT\s+(?:(\'\d+\')|(\d+)|(:\w+))\s+ROWS\s+ONLY/";
                                preg_match_all($lastLimit, $sql, $allLimitClause);
                                if ($allLimitClause[0]) {
                                    $last_match = end($allLimitClause[0]);
                                    $sql = preg_replace($lastLimit, '', $sql);
                                    $sql .= ' ' . $last_match;
                                }
                            } else {
                                $sql = preg_replace('/SELECT\s+(.*?)\s+FROM\s+(.*?)(?=(?:\s+WHERE|\s+GROUP\s+BY|\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$))/i', 'SELECT DISTINCT $1, FROM $2', $sql, 1);
                                $sql = preg_replace('/\s+GROUP\s+BY\s+".*?"\s*,\s*".*?"\s*,\s*".*?"\s*/i', ' ', $sql);
                            }
                        }
                    } else {
                        if (preg_match('/\bcount\s*\(\s*\*\s*\)/i', $sql)) {
                            // $sql = preg_replace('/\bCOUNT\(\*\)\b/i', ' COUNT(*) OVER() ', $sql);
                        }
                    }
                }
            }
        }

        if (strpos($sql, 'BASIC_ONLY') === true && $columnsGroupBY) {
            $sql = preg_replace('/\bcount\s*\(\s*\*\s*\)/i', 'COUNT(' . $columnsGroupBY . ')', $sql);
        }

        $syntax = array(
            '/\bUNSIGNED INT\b/i' => 'NUMBER',
            '/\bUNSIGNED\b/i' => '',
            '/\bENGINE=InnoDB\b/i' => '',
            '/\bENGINE=MyISAM\b/i' => '',
            '/\bUSING BTREE\b/i' => '',
            '/\bCHARSET=utf8mb4\b/i' => '',
            '/\bCHARSET=utf8\b/i' => '',
            '/\bTEXT\b/i' => 'VARCHAR2(4000)',
            '/\bTINYTEXT\b/i' => 'VARCHAR2(255)',
            '/\bMEDIUMTEXT\b/i' => 'VARCHAR2(4000)',
            '/\bLONGTEXT\b/i' => 'VARCHAR2(4000)',
            '/\bENUM\((.*?)\)\b/i' => 'VARCHAR2($1)',
            '/\bSET\((.*?)\)\b/i' => 'VARCHAR2($1)',
            '/\bBLOB\b/i' => 'BLOB',
            '/\bNOT NULL AUTO_INCREMENT\b/i' => 'GENERATED BY DEFAULT ON NULL AS IDENTITY',
            '/\bVARCHAR\((\d+)\)\s*COLLATE\s*[a-zA-Z0-9_]+\b/i' => 'VARCHAR2($1)',
            '/\bINT\(\d+\)\b/i' => 'NUMBER',
            '/\bBIT\b/i' => 'NUMBER(1)',
        );
        $sql = preg_replace(array_keys($syntax), array.values($syntax), $sql);

        // Handle INSERT statements with multiple rows
        $pattern = '/"([^"]*)"\."([^"]*)"/';
        preg_match_all($pattern, $sql, $findAliases);
        if ($findAliases) {
            $aliases = array_unique($findAliases[1]);
            foreach ($aliases as $alias) {
                if (!is_numeric($alias)) {
                    $pattern = '/(?<!:)(?<!")\b' . preg_quote($alias) . '\b(?!")/';
                    $sql = preg_replace($pattern, '"$0"', $sql);
                }
            }
        }

        if (preg_match('/\bcount\s*\((?!\*)/i', $sql)) {
            $patternSelect = '/count\(([^)]+)\)\s+AS\s+"([^"]+)"/i';
            preg_match('/count\(([^)]+)\)\s+AS\s+"([^"]+)"/i', $sql, $aliasNames);
            $columnMerged = '';
            if ($columnsGroupBY) {
                $columnMerged = " $columnsGroupBY, ";
            }
            if (preg_match($patternSelect, $sql) && $columnsGroupBY) {
                $sql = preg_replace($patternSelect, 'COUNT_CONVERT(' . $columnsGroupBY . ') OVER (PARTITION BY ' . $columnsGroupBY . ') "$2"', $sql);
                $sql = preg_replace_callback('/count\(([^)]+)\)/i', function ($findCount) use ($aliasNames, $sql, $columnsGroupBY) {
                    if ($findCount) {
                        if ($findCount[1] === '*') {
                            return 'COUNT(*)';
                        } else {
                            if (!preg_match('/SELECT\s+COUNT\(\s*("[^"]+"|\S+)\s*\)\s+FROM\s+(.*?)\s+WHERE/i', $sql))
                                return '"' . $aliasNames[2] . '"';
                            else
                                return $findCount[0];
                        }
                    }
                }, $sql);
                $sql = str_replace('COUNT_CONVERT', 'COUNT', $sql);
            }
        }

        $sql = preg_replace_callback('/SUM\(([^)]+)\)/', function ($matches) {
            if (strpos($matches[1], '"') !== 0 || strrpos($matches[1], '"') !== strlen($matches[1]) - 1) {
                return 'SUM("' . $matches[1] . '")';
            } else {
                return $matches[0];
            }
        }, $sql);

        $sql = preg_replace('/\bow_([a-zA-Z_]\w*)\b/', '"ow_$1"', $sql);
        $sql = self::removeAliases($sql);

        // Replace dates
        $sql = preg_replace(
            '/YEAR\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
            'EXTRACT(YEAR FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
            $sql
        );
        $sql = preg_replace(
            '/MONTH\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
            'EXTRACT(MONTH FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
            $sql
        );
        $sql = preg_replace(
            '/DAY\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
            'EXTRACT(DAY FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
            $sql
        );
        $sql = preg_replace(
            '/HOUR\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
            'EXTRACT(HOUR FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
            $sql
        );

        // Replace & with BITAND
        $sql = preg_replace_callback('/("([a-zA-Z_]+)"\."([^"]+)"\s*&\s*(:\w+))/', function ($matches) {
            $matches[2] = '"' . $matches[2] . '"';
            $matches[3] = '"' . $matches[3] . '"';
            return " BITAND({$matches[2]}.{$matches[3]}, {$matches[4]}) > 0";
        }, $sql);
        $sql = preg_replace('/"([^"]+)"\."([^"]+)" & (\d+)/', 'BITAND("$1"."$2", $3) > 0', $sql);
        $sql = preg_replace('/"([^"]+)"\s&\s([^ ]+)/', 'BITAND("$1", $2) > 0', $sql);

        // Replace "MONTH"(...) with EXTRACT(MONTH FROM ...)
        $sql = preg_replace('/"MONTH"\((.*?)\)/i', 'EXTRACT(MONTH FROM $1)', $sql);
        $sql = preg_replace('/"DAY\((.*?)\)"/i', 'EXTRACT(DAY FROM $1)', $sql);
        $sql = preg_replace('/"YEAR\((.*?)\)"/i', 'EXTRACT(YEAR FROM $1)', $sql);

        $sql = preg_replace('/\|\|/', 'OR', $sql);
        $sql = preg_replace('/UNIX_TIMESTAMP\(\)/', 'SYSTIMESTAMP', $sql);
        $sql = preg_replace('/(?<=[\s]|^)(?![0-9]+)([^:\s"=<>!]+)(?=[\s]*=[\s]*[^"!]*)/m', '"$1"', $sql);

        $sql = preg_replace('/""/', '"', $sql);
        $sql = preg_replace('/"\s+\'/', '"', $sql);
        $sql = preg_replace('/\'\s+"/', '"', $sql);
        $sql = preg_replace('/\s*=\s*/', '=', $sql);
        $sql = preg_replace('/(?<![=0-9.])\b(1\s*AND|true\s*AND)\b/i', '1=1 AND', $sql);
        $sql = preg_replace('/AND 1\b/i', 'AND 1=1', $sql);
        $sql = preg_replace('/(?<=[.\d=\s>!<])true\s+AND\b/i', '1=1', $sql);
        $sql = preg_replace('/1=1=1/', '1=1', $sql);
        $sql = preg_replace('/(?<=\d)=1=1(?=\d)/', '=1', $sql);
        $sql = preg_replace('/\b(?:\d{4}-%m-%d|%y-%m-%d)\b/', 'YYYY-MM-DD', $sql);
        $sql = preg_replace('/\bAND\s*\(\s*1\s*\)/', 'AND(1=1)', $sql);

        if (preg_match('/ON DUPLICATE KEY UPDATE/i', $sql)) {
            $pattern2 = '/INSERT INTO "([^"]+)"\("([^"]+)"\s*,[^)]+\) VALUES \(([^)]+)\) ON DUPLICATE KEY UPDATE "([^"]+)"=([^,]+), "([^"]+)"=([^)]+)/i';
            $pattern = '/INSERT INTO "[^"]+"\(([^)]+)\) VALUES \(([^)]+)\) ON DUPLICATE KEY UPDATE "[^"]+"=([^,]+), "[^"]+"=([^)]+)/i';
            preg_match($pattern, $sql, $source2Target);
            preg_match($pattern2, $sql, $otherMathces);

            $column = explode(',', $source2Target[1]);
            $values = explode(',', $source2Target[2]);
            foreach ($column as $index => $ky) {
                $selectClause[] = $values[$index] . ' AS ' . $ky;
                if ($index > 0) {
                    $updateClause[] = '"' . $ky . '"=' . $values[$index];
                }
            }
            $selectClause = implode(',', $selectClause);
            $updateClause = implode(',', $updateClause);
            $otherMathces[1] = '"' . $otherMathces[1] . '"';
            $replacement = "MERGE INTO {$otherMathces[1]} tgt USING (SELECT {$selectClause} FROM DUAL) src ON (tgt.{$column[0]} = src.{$column[0]}) WHEN MATCHED THEN UPDATE SET {$updateClause} WHEN NOT MATCHED THEN INSERT ({$source2Target[1]}) VALUES ({$source2Target[2]})";
            $sql = preg_replace($pattern, $replacement, $sql);
        }

        $sql = str_replace('BASIC_ONLY', '', $sql);
    }

    /**
     * Executes an SQL statement.
     *
     * @param string $sql The SQL query.
     * @param array|null $params The parameters for the query.
     * @param PDO $connection The PDO connection object.
     * @return PDOStatement The prepared and executed PDO statement.
     * @throws Exception If an error occurs during query execution.
     */
    public static function execute(string $sql, ?array $params = null, PDO $connection): PDOStatement
    {
        if (DB_TYPE == 'ORACLE') {
            self::convertSqlForOracle($sql);
        }

        $stmt = $connection->prepare($sql);
        if ($params !== null) {
            foreach ($params as $key => $value) {
                $paramType = PDO::PARAM_STR;
                if (is_int($value)) {
                    $paramType = PDO::PARAM_INT;
                } elseif (is_bool($value)) {
                    $paramType = PDO::PARAM_BOOL;
                }
                $stmt->bindValue(is_int($key) ? $key + 1 : $key, $value, $paramType);
            }
        }
        try {
            $stmt->execute();
        } catch (Exception $ex) {
            throw $ex;
        }

        return $stmt;
    }

    /**
     * Inserts a record into the database and returns the last insert ID.
     *
     * @param string $sql The SQL query.
     * @param array|null $params The parameters for the query.
     * @param PDO $connection The PDO connection object.
     * @return int The last insert ID.
     */
    public static function insert(string $sql, ?array $params = null, PDO $connection): int
    {
        if (DB_TYPE == 'ORACLE') {
            $sql = "DECLARE
            inserted_id NUMBER;
            BEGIN
            {$sql}
            RETURNING \"id\" INTO :insertedId;
            END;";
        }
        $lastInsertId = 0;
        $stmt = self::execute($sql, $params, $connection);

        if (DB_TYPE == 'MYSQL') {
            $lastInsertId = $connection->lastInsertId();
        }
        $stmt->closeCursor();
        return $lastInsertId;
    }

    /**
     * Removes aliases from the SQL query.
     *
     * @param string $sql The SQL query.
     * @return string The SQL query without aliases.
     */
    public static function removeAliases(string $sql): string
    {
        $sql = preg_replace('/(?<!:)\bAS\s+([^,\s"]+)/i', 'AS "$1"', $sql);
        $sql = preg_replace('/(?<!:)\bAS\b/i', ' ', $sql);

        return $sql;
    }
}
?>
