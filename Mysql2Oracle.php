<?php 

define('DB_TYPE', 'ORACLE'); 

$connection = new PDO("oci:dbname=" . $dbtns . ";charset=utf8", $db_username, $db_password, array(
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_EMULATE_PREPARES => false,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_NUM));

function convertSqlForOracle(&$sql)
{
    if (preg_match('/SELECT COL.COLUMN_NAME/i', $sql)) {
        return;
    }

    // Replace MySQL-specific keywords with equivalent Oracle keywords
    $keywords = array(
        '/\bAUTO_INCREMENT\b/i' => 'GENERATED BY DEFAULT ON NULL AS IDENTITY',
    );
    $columnsGroupBY='';
    $sql = preg_replace(array_keys($keywords), array_values($keywords), $sql);

    // Replace MySQL-specific functions with equivalent Oracle functions
    $functions = array(
        '/\bDATE_FORMAT\b/i' => 'TO_CHAR',
        '/\bIFNULL\b/i' => 'NVL',
        '/\bNOW\(\)\b/i' => 'SYSDATE',
    );
        // Replace IF with CASE using regex

    $sql = preg_replace(array_keys($functions), array_values($functions), $sql);
    
    $sql = preg_replace('/IF\s*\(\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^)]+)\s*\)/', 'CASE WHEN $1 THEN $2 ELSE $3 END', $sql);

    // Replace backticks with double quotations for table names and column names
    $sql = preg_replace('/`([^`]+)`/', '"$1"', $sql);
    $sql = preg_replace('/\s{2,}/', ' ', $sql);
    $sql = preg_replace('/show tables like :(\w+)/i', "SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE :$1", $sql);
    $sql = preg_replace("/SHOW VARIABLES LIKE '([^']+)%'/i", "SELECT name, value FROM v\$parameter WHERE name LIKE '$1%';", $sql);
    $sql = preg_replace('/SHOW VARIABLES LIKE ([\'"])([^\'"]+)\\1/', 'SELECT name, value FROM v$parameter WHERE name LIKE '."'$2%'".' ', $sql);
   // $sql = preg_replace("/\s+OR ''/", "", $query);


     // Enclose column names and table names within double quotations
     $sql = preg_replace_callback('/\b(?:FROM|JOIN)\s+(\S+)/i', function($matches) {
        $tableName = $matches[1];
        if (strpos($tableName, '`') !== false || strpos($tableName, '"') !== false || strpos($tableName, '(') !== false || $tableName=='v$parameter' || $tableName=='ROWS') {
            return $matches[0];
        }
        return str_replace($tableName, '"' . $tableName . '"', $matches[0]);
    }, $sql);
      // Enclose table names within double quotations in UPDATE and INSERT statements
      $sql = preg_replace_callback('/\b(?:UPDATE|INSERT\s+INTO)\s+(\S+)/i', function($matches) {
        $tableName = $matches[1];
        if (strpos($tableName, '`') !== false || strpos($tableName, '"') !== false) {
            return $matches[0];
        }
        return str_replace($tableName, '"' . $tableName . '"', $matches[0]);
    }, $sql);

    $sql = preg_replace_callback('/(\b\w+\b)(?=\s*IN\b)/i', function($match) {
        if(trim(strtolower($match[1]))!='not')
        return '"' . $match[1] . '"';
        else
        return $match[1] ;
    }, $sql);


    // Enclose column names in expressions like x.y within double quotations
    
    $sql = preg_replace_callback("/\.(\w+)'?/", function($dotMatch)  {
    $last = substr($dotMatch[0], -1);
    if($last=="'")
        return $dotMatch[0];
    else 
    return '."'.$dotMatch[1].'"' ;
    }, $sql);

   
    $sql = preg_replace_callback("/\'?(\w+)\./", function($dotMatch)  {
        $first = substr($dotMatch[0], 0, 1);
        if($first=="'")
        return $dotMatch[0];
        else 
        return '"'.$dotMatch[1].'".' ;
        
    }, $sql);

    $sql = preg_replace('/"(\d+(?:\.\d+)?)"/', '$1', $sql);

     // remove Distinct from count
     $sql = preg_replace('/count\s*\(\s*DISTINCT\s*(.*?)\s*\)/i', 'count($1)', $sql);
     $sql = preg_replace('/count\("(.*?)"\) "(.*?)"(?!\s*AS)/i', 'count("$1") AS "$2"', $sql);



    //LIMIT
    if (preg_match_all('/\bLIMIT\s+((:\w+)|(\d+)(?:\s*,\s*(\d+))?)(?:\s*,\s*((:\w+)|(\d+)(?:\s*,\s*(\d+))?))?\b/i', $sql, $limitMatches, PREG_SET_ORDER)) {
        foreach ($limitMatches as $match) {
        $limitClause =$match[0];
        // Step 1: Remove "LIMIT" and spaces from the input string
        $limitClause = str_replace(['LIMIT', ' ', '"'], '', $limitClause);
        // Step 2: Explode the cleaned string into an array using the comma as the delimiter
        $limitClause = explode(',', $limitClause);
        // Step 3: Trim any remaining spaces from each element in the array
        $offsets = array_map('trim', $limitClause);
        if(sizeof($offsets)==1){
            $start=0;
            $end=$offsets[0];
        }else{
            $start=$offsets[0];
            $end=$offsets[1];
        }
            // Replace the LIMIT clause with OFFSET and FETCH NEXT
            $replacement = 'OFFSET ' . $start . ' ROWS FETCH NEXT ' . $end . ' ROWS ONLY';
            $sql = preg_replace('/\bLIMIT\s+((:\w+)|(\d+)(?:\s*,\s*(\d+))?)(?:\s*,\s*((:\w+)|(\d+)(?:\s*,\s*(\d+))?))?\b/i', $replacement, $sql, 1); // Use 1 as the fourth parameter to replace only the first occurrence
        }
    }
    if (preg_match('/\bLIMIT\s+\?\s*,\s*\?/i', $sql)) {
      $sql = preg_replace('/\bLIMIT\s+\?\s*,\s*\?/i', 'OFFSET ? ROWS FETCH NEXT ? ROWS ONLY', $sql);
    }
    if (preg_match('/IF\s*\((.*?)\)/i', $sql)) {
    $sql = preg_replace('/IF\((.*?),\s*(.*?),\s*(.*?)\)/', 'CASE WHEN $1 THEN $2 ELSE $3 END', $sql);
    }
    if(strpos($sql, 'BASIC_ONLY') === false){
    // Enclose column names after ORDER BY within double quotations
 
    if (preg_match('/\bORDER BY\b/i', $sql)) {
     $pattern = '/\bORDER\s+BY\s+([^;]+)/i';
     if (preg_match($pattern, $sql, $matches)) {
        $orderByClause = $matches[1];
        $containsComma = strpos($orderByClause, ',') !== false;}
    if($containsComma){
        $sql = preg_replace('/ORDER BY (?!CASE\b|MAX\b)(?!.*\bcount\()(\\w+)/i', 'ORDER BY "$1"', $sql);
        $sql = preg_replace('/ORDER BY(.*?)(?<=,|^)\s*([^,\s]{5,})/', 'ORDER BY$1 "$2"', $sql);
    }
    else{
        $sql = preg_replace('/ORDER BY (?!CASE\b|MAX\b)(?!.*\bcount\()(\\w+)/i', 'ORDER BY "$1"', $sql);
    }

    // remove max(argument) with argumet
    $sql = preg_replace_callback('/ORDER\s+BY\s+(.*?)(MAX\([^)]+\))(.*)/i', function ($matches) {
        // Extract only the argument inside MAX() and preserve the rest
        $argument_inside_max = preg_replace('/MAX\(([^)]+)\)/i', '$1', $matches[2]);
    
        // Reconstruct the ORDER BY clause with MAX() replaced by its argument
        return 'ORDER BY ' . $matches[1] . $argument_inside_max . $matches[3];
    }, $sql);


    }
    // AVG function 
    // Regular expression pattern to match the AVG function
    $sql = preg_replace('/AVG\s*\([^()]*\)/i', '$0 OVER()', $sql);
    // GroupBy
    if (!preg_match('/^\s*DELETE\s+FROM\s+/i', $sql) &&  strpos($sql, 'NUMTODSINTERVAL') === false) {
    if (preg_match_all('/\bGROUP BY\b(?!\s+CASE)/i', $sql,$occourences)) {
    if(count($occourences[0])==1){
    //$sql = preg_replace('/\s+ORDER\s+BY\b.*?(?=\s+GROUP\s+BY|$)/is', '', $sql);
    if (strpos($sql, 'FROM_UNIXTIME') === false ) {
    

    $sql = preg_replace_callback('/GROUP\s+BY\s+(.*?)(?=(?:\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$))/i', function($matches) use (&$columnsGroupBY){
       $columnsGroupBY = $matches[1];
    }, $sql);
    // Pattern to match the SELECT COUNT(*) query

    // Perform the regular expression match
    //if (!preg_match('/SELECT\s+COUNT\(\*\)\s+FROM\s+(.*?)\s+WHERE/i', $sql)) 
    if($columnsGroupBY)
    $sql = preg_replace('/\bcount\s*\(\s*\*\s*\)/i', 'COUNT('.$columnsGroupBY.')', $sql);
    preg_match('/count\(([^)]+)\)\s+AS\s+"([^"]+)"/i', $sql,$orderBycount);
    $orderBycountMerge='';
   if($orderBycount && $orderBycount[1]){
      $orderBycountMerge=" ,$orderBycount[1]";
    } 
    $sql = preg_replace('/SELECT\s+(.*?)\s+FROM\s+(.*?)(?=(?:\s+WHERE|\s+GROUP\s+BY|\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$))/i', 'SELECT $1, ROW_NUMBER() OVER (PARTITION BY ' . $columnsGroupBY . ' ORDER BY ' . $columnsGroupBY .$orderBycountMerge .') "rn" FROM $2', $sql,1);

    $sql = 'SELECT * FROM (' . $sql . ') WHERE rn = 1';

    //transfer limit to the end of query
    $lastLimit = "/OFFSET\s+(?:(\'\d+\')|(\d+)|(:\w+))\s+ROWS\s+FETCH\s+NEXT\s+(?:(\'\d+\')|(\d+)|(:\w+))\s+ROWS\s+ONLY/";
    // Find all occurrences of the pattern in the statement
    $allLimitClause=array();
    preg_match_all($lastLimit, $sql, $allLimitClause);
    
    // If there are any matches, extract the last one
    if($allLimitClause[0]){
    $last_match = end($allLimitClause[0]);
    
    // Remove the last match from its original position in the statement
    $sql = preg_replace($lastLimit, '', $sql);
    
    // Append the last match at the end of the statement
    $sql .= ' ' . $last_match;
    }
      }else{
        $sql = preg_replace('/SELECT\s+(.*?)\s+FROM\s+(.*?)(?=(?:\s+WHERE|\s+GROUP\s+BY|\s+HAVING|\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|$))/i', 'SELECT DISTINCT $1, FROM $2', $sql,1);
        $sql = preg_replace('/\s+GROUP\s+BY\s+".*?"\s*,\s*".*?"\s*,\s*".*?"\s*/i', ' ', $sql);

      }
    }
    }else{

        if(preg_match('/\bcount\s*\(\s*\*\s*\)/i',$sql)){
           // $sql = preg_replace('/\bCOUNT\(\*\)\b/i', ' COUNT(*) OVER() ', $sql);
        }
    }

}
}
if(strpos($sql, 'BASIC_ONLY') === true && $columnsGroupBY){
$sql = preg_replace('/\bcount\s*\(\s*\*\s*\)/i', 'COUNT('.$columnsGroupBY.')', $sql);
}
    $syntax = array(
        '/\bUNSIGNED INT\b/i' => 'NUMBER',
        '/\bUNSIGNED\b/i' => '',
        '/\bENGINE=InnoDB\b/i' => '',
        '/\bENGINE=MyISAM\b/i' => '',
        '/\bUSING BTREE\b/i' => '',
        '/\bCHARSET=utf8mb4\b/i' => '',
        '/\bCHARSET=utf8\b/i' => '',
        '/\bTEXT\b/i' => 'VARCHAR2(4000)',
        '/\bTINYTEXT\b/i' => 'VARCHAR2(255)',
        '/\bMEDIUMTEXT\b/i' => 'VARCHAR2(4000)',
        '/\bLONGTEXT\b/i' => 'VARCHAR2(4000)',
        '/\bENUM\((.*?)\)\b/i' => 'VARCHAR2($1)',
        '/\bSET\((.*?)\)\b/i' => 'VARCHAR2($1)',
        '/\bBLOB\b/i' => 'BLOB',
        '/\bNOT NULL AUTO_INCREMENT\b/i' => 'GENERATED BY DEFAULT ON NULL AS IDENTITY',
        '/\bVARCHAR\((\d+)\)\s*COLLATE\s*[a-zA-Z0-9_]+\b/i' => 'VARCHAR2($1)',
        '/\bINT\(\d+\)\b/i' => 'NUMBER',
        '/\bBIT\b/i' => 'NUMBER(1)',
    );
    $sql = preg_replace(array_keys($syntax), array_values($syntax), $sql);
    // Handle INSERT statements with multiple rows
    // Reduce "AS" aliases
    $pattern = '/"([^"]*)"\."([^"]*)"/';

    // Find all occurrences of the pattern
    $findAliases = array();
    preg_match_all($pattern, $sql, $findAliases);
    if($findAliases){
    $aliases=array();
    $aliases=array_unique($findAliases[1]);
    foreach ($aliases as $alias) {
        if(!is_numeric($alias)){
        $pattern = '/(?<!:)(?<!")\b' . preg_quote($alias) . '\b(?!")/';
    
        // Perform the string
        $sql = preg_replace($pattern, '"$0"', $sql);
        }
    }}
    if (preg_match('/\bcount\s*\((?!\*)/i', $sql)) 
    {
        $patternSelect = '/count\(([^)]+)\)\s+AS\s+"([^"]+)"/i';
        preg_match('/count\(([^)]+)\)\s+AS\s+"([^"]+)"/i', $sql,$aliasNames);
        // Use preg_replace to replace the pattern in the input string
        $columnMerged='';
        if($columnsGroupBY){
            $columnMerged=" $columnsGroupBY, ";
        }
        if(preg_match($patternSelect, $sql) && $columnsGroupBY) {
          $sql = preg_replace($patternSelect, 'COUNT_CONVERT('.$columnsGroupBY.') OVER (PARTITION BY '.$columnsGroupBY.') "$2"', $sql);
       // Use preg_replace to replace the pattern in the input string
           $findCount=array();
        $sql = preg_replace_callback('/count\(([^)]+)\)/i', function ($findCount) use ($aliasNames,$sql,$columnsGroupBY) {
        // Check if the captured group is an asterisk (*)
        if($findCount){
        if ($findCount[1] === '*') {
            return 'COUNT(*)';
        } else {
            if (!preg_match('/SELECT\s+COUNT\(\s*("[^"]+"|\S+)\s*\)\s+FROM\s+(.*?)\s+WHERE/i', $sql) /* && strpos($sql, "COUNT($columnsGroupBY) OVER (PARTITION BY") === false */ ) 
            return '"' . $aliasNames[2] . '"';
            else
            return $findCount[0];

        }
    }
    
    }, $sql);
    $sql = str_replace('COUNT_CONVERT', 'COUNT', $sql);

    }
    }

    // Perform the replacement using preg_replace_callback
    $sql = preg_replace_callback('/SUM\(([^)]+)\)/', function ($matches) {
    // Check if the argument is already enclosed in double quotes
    if (strpos($matches[1], '"') !== 0 || strrpos($matches[1], '"') !== strlen($matches[1]) - 1) {
        // Enclose the argument in double quotes
        return 'SUM("' . $matches[1] . '")';
    } else {
        // The argument is already enclosed in double quotes, no need to change
        return $matches[0];
    }
}, $sql);

    // Regular expression pattern
    // Replace the matched words with double quotations if not already enclosed, just for resan used
    $sql = preg_replace('/\bow_([a-zA-Z_]\w*)\b/', '"ow_$1"', $sql);
    $sql = removeAliases($sql);
    //change DATE AND TIME 
    if (strpos($sql, 'FROM_UNIXTIME') == true) {
    $sql = preg_replace(
        '/YEAR\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
        'EXTRACT(YEAR FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
        $sql
    );
    $sql = preg_replace(
        '/MONTH\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
        'EXTRACT(MONTH FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
        $sql
    );
    $sql = preg_replace(
        '/DAY\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
        'EXTRACT(DAY FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
        $sql
    );
    $sql = preg_replace(
        '/HOUR\s*\( FROM_UNIXTIME\s*\(\s*"([^"]+)"\s*\)\s*\)\s*("([^"]+)")/',
        'EXTRACT(HOUR FROM TO_DATE(\'1970-01-01\', \'YYYY-MM-DD\') + NUMTODSINTERVAL("$1", \'SECOND\')) AS $2',
        $sql
    );
    $sql = preg_replace('/\s*,\s*FROM\s+/i', ' FROM ', $sql);
    }
    // replace & with bitand
    $sql = preg_replace_callback('/("([a-zA-Z_]+)"\."([^"]+)"\s*&\s*(:\w+))/', function($matches) {
        $matches[2]='"'.$matches[2].'"';
        $matches[3]='"'.$matches[3].'"';
        return " BITAND({$matches[2]}.{$matches[3]}, {$matches[4]}) > 0";
    }, $sql);
    $sql = preg_replace('/"([^"]+)"\."([^"]+)" & (\d+)/', 'BITAND("$1"."$2", $3) > 0', $sql);

    $sql = preg_replace('/"([^"]+)"\s&\s([^ ]+)/', 'BITAND("$1", $2) > 0', $sql);
    
    // Replace "MONTH"(...) with EXTRACT(MONTH FROM ...)
    $sql = preg_replace('/"MONTH"\((.*?)\)/i', 'EXTRACT(MONTH FROM $1)', $sql);
    // Replace "DAY("...")" with EXTRACT(DAY FROM ...)
    $sql = preg_replace('/"DAY\((.*?)\)"/i', 'EXTRACT(DAY FROM $1)', $sql);
     // Replace "Year("...")" with EXTRACT(Year FROM ...)
    $sql = preg_replace('/"YEAR\((.*?)\)"/i', 'EXTRACT(YEAR FROM $1)', $sql);

    $sql = preg_replace('/\|\|/', 'OR', $sql);
    // Replace UNIX_TIMESTAMP() with SYSTIMESTAMP
    $sql = preg_replace('/UNIX_TIMESTAMP\(\)/', 'SYSTIMESTAMP', $sql);
    //enclose column name befor =
    $sql = preg_replace('/(?<=[\s]|^)(?![0-9]+)([^:\s"=<>!]+)(?=[\s]*=[\s]*[^"!]*)/m', '"$1"', $sql);

    $sql = preg_replace('/""/', '"', $sql);
    $sql = preg_replace('/"\s+\'/', '"', $sql);
    $sql = preg_replace('/\'\s+"/', '"', $sql);
    //remove 1 AND , true AND
    $sql = preg_replace('/\s*=\s*/', '=', $sql);

    // Replace "true AND" with "1=1" if preceded by specific characters
   $sql = preg_replace('/(?<![=0-9.])\b(1\s*AND|true\s*AND)\b/i', '1=1 AND', $sql);
   $sql = preg_replace('/AND 1\b/i', 'AND 1=1', $sql);
   $sql = preg_replace('/(?<=[.\d=\s>!<])true\s+AND\b/i', '1=1', $sql);
   $sql = preg_replace('/1=1=1/', '1=1', $sql);
   $sql = preg_replace('/(?<=\d)=1=1(?=\d)/', '=1', $sql);
// Replace the old date format '2023-%m-%d' and '2024-%m-%d' with the new format 'YYYY-MM-DD'
  $sql = preg_replace('/\b(?:\d{4}-%m-%d|%y-%m-%d)\b/', 'YYYY-MM-DD', $sql);
  $sql = preg_replace('/\bAND\s*\(\s*1\s*\)/', 'AND(1=1)', $sql);
  if (preg_match('/ON DUPLICATE KEY UPDATE/i', $sql)) {
    $pattern2 = '/INSERT INTO "([^"]+)"\("([^"]+)"\s*,[^)]+\) VALUES \(([^)]+)\) ON DUPLICATE KEY UPDATE "([^"]+)"=([^,]+), "([^"]+)"=([^)]+)/i';
    $pattern = '/INSERT INTO "[^"]+"\(([^)]+)\) VALUES \(([^)]+)\) ON DUPLICATE KEY UPDATE "[^"]+"=([^,]+), "[^"]+"=([^)]+)/i';

    // Replacement pattern for the Oracle MERGE statement
    preg_match($pattern, $sql , $source2Target);
    preg_match($pattern2, $sql , $otherMathces);
    $column=explode(',',$source2Target[1]);
    $values=explode(',',$source2Target[2]);
    foreach ($column as $index => $ky) {
        $selectClause[]= $values[$index ].' AS '.$ky;
        if($index>0){
            $updateClause[] = '"' . $ky . '"=' . $values[$index ];
        }
    }
    $selectClause = implode(',',$selectClause);
    $updateClause = implode(',',$updateClause);
    $otherMathces[1]='"'.$otherMathces[1].'"';
    $replacement = "MERGE INTO {$otherMathces[1]} tgt USING (SELECT {$selectClause} FROM DUAL) src ON (tgt.{$column[0]} = src.{$column[0]}) WHEN MATCHED THEN UPDATE SET {$updateClause} WHEN NOT MATCHED THEN INSERT ({$source2Target[1]}) VALUES ({$source2Target[2]})";
    $sql = preg_replace($pattern, $replacement, $sql);
  }
  $sql = str_replace('BASIC_ONLY', '', $sql);


}

function removeAliases($sql)
{
   
    // Remove "AS" keyword
    $sql = preg_replace('/(?<!:)\bAS\s+([^,\s"]+)/i', 'AS "$1"', $sql);
    $sql = preg_replace('/(?<!:)\bAS\b/i', ' ', $sql);

    return  $sql;

}
 function insert( $sql, array $params = null ,$connection)
{
    //$connection = new PDO('oci:host=localhost;dbname=test', 'username', 'password');

    if (DB_TYPE=='ORACLE'){
    $sql="DECLARE
    inserted_id NUMBER;
    BEGIN
    {$sql}
    RETURNING ".'"'.'id'.'"'." INTO :insertedId;
    END;";
    }
    $lastInsertId=0;
    $stmt = execute($sql, $params,'',$lastInsertId);

    if (DB_TYPE=='MYSQL')
    $lastInsertId = $connection->lastInsertId();
    $stmt->closeCursor();
    return $lastInsertId;
 
}

 function execute( $sql, array $params = null, $retry = false ,&$insertedId=0,$connection)
{
   //s $connection = new PDO('mysql:host=localhost;dbname=test', 'username', 'password');

    $keyDeclaration='';
    $keyAssignment='';
    if (DB_TYPE=='ORACLE')
    convertSqlForOracle($sql);

  
    if (DB_TYPE=='ORACLE' && $params !== null )
    {
    foreach ( $params as $key => $value )
        { 
            if (preg_match_all('/:' .$key. '\b/', $sql,$matchParam)) {
                if($matchParam){
                    if (strlen($value) > 4000) {
                        $isLong=true;
                        $keyDeclaration .= " v_$key VARCHAR2(32767);";
                        $keyAssignment .= " v_$key :=".$connection->quote($value).";";
                        $sql = preg_replace('/:' . preg_quote($key, '/') . '\b/', 'v_'.$key, $sql);

                        } else {
                        $sql = preg_replace('/:' . preg_quote($key, '/') . '\b/', $connection->quote($value), $sql);
                            }
                        $paramRemain[$key]=$value;
                        }
              }

        }
        if($isLong){
            $sql = "DECLARE $keyDeclaration BEGIN $keyAssignment $sql;    COMMIT;
            EXCEPTION
                WHEN OTHERS THEN
                    ROLLBACK;
                    RAISE; END;";
        }
    }
    $sql = preg_replace("/\s+OR ''/", "", $sql);
    $sql = preg_replace("/\s+OR '1'/", "", $sql);

    $stmt = $connection->prepare($sql);
    if ( $params !== null )
    {
        if(sizeof($paramRemain)>0){
            foreach ( $paramRemain as $key => $value )
            {
                unset($params[$key]);
            }
        }
        foreach ( $params as $key => $value )
        {
            
            $paramType = PDO::PARAM_STR;
            if ( is_int($value) )
                $paramType = PDO::PARAM_INT;
            elseif ( is_bool($value) )
                $paramType = PDO::PARAM_BOOL;

            $stmt->bindValue(is_int($key) ? $key + 1 : $key, $value, $paramType);
        }
    }
    if (DB_TYPE=='ORACLE'){
        if (preg_match('/DECLARE\s+inserted_id\s+NUMBER;/', $sql)) {
            $insertedId=0;
            $stmt->bindParam(':insertedId', $insertedId, PDO::PARAM_INT | PDO::PARAM_INPUT_OUTPUT, 8);
        }
    }
    try{
        //TODO setup profiler
        $stmt->execute(); 
    }
    catch (Exception $ex){
        $msg = $ex->getMessage();

        throw $ex;
    }

    
    return $stmt;
}


?>
